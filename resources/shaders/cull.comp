#version 460 core

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct DrawElementsIndirectCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

struct MeshInfo {
    uint indexCount;
    uint firstIndex;
    uint baseVertex;
    float boundingRadius;
    vec4 boundingCenter;
};

layout(binding = 0, offset = 0) uniform atomic_uint drawCount;
layout(binding = 1, std430) buffer DrawCommandBuffer {
    DrawElementsIndirectCommand commands[];
};

layout(binding = 2, std430) readonly buffer ObjectBuffer {
    mat4 models[];
};

layout(binding = 3, std430) readonly buffer MeshInfoBuffer {
    MeshInfo meshInfos[];
};

uniform uint u_objectCount;
uniform mat4 u_viewProjection;

bool isVisible(vec4 clip_pos, float radius) {
    return clip_pos.x >= -clip_pos.w - radius && clip_pos.x <= clip_pos.w + radius &&
           clip_pos.y >= -clip_pos.w - radius && clip_pos.y <= clip_pos.w + radius &&
           clip_pos.z >= -clip_pos.w - radius && clip_pos.z <= clip_pos.w + radius;
}

void main() {
    uint objectId = gl_GlobalInvocationID.x;
    if (objectId >= u_objectCount) return;

    MeshInfo mesh = meshInfos[0];
    mat4 modelMatrix = models[objectId];

    vec4 world_pos = modelMatrix * mesh.boundingCenter;
    vec4 clip_pos = u_viewProjection * world_pos;

    float world_radius = mesh.boundingRadius * max(length(modelMatrix[0]), max(length(modelMatrix[1]), length(modelMatrix[2])));

    if (isVisible(clip_pos, world_radius)) {
        uint index = atomicCounterIncrement(drawCount);
        commands[index].instanceCount = 1;
        commands[index].baseInstance = objectId;
        commands[index].count = mesh.indexCount;
        commands[index].firstIndex = mesh.firstIndex;
        commands[index].baseVertex = mesh.baseVertex;
    }
}

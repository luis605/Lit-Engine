#version 460 core

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct DrawElementsIndirectCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

struct MeshInfo {
    uint indexCount;
    uint firstIndex;
    uint baseVertex;
    float boundingRadius;
    vec4 boundingCenter;
};

struct RenderableComponent {
    uint mesh_uuid;
    uint material_uuid;
    uint shaderId;
    uint objectId;
    float alpha;
};

struct TransformComponent {
    mat4 localMatrix;
    mat4 worldMatrix;
};

layout (std140) uniform SceneUniforms {
    mat4 projection;
    mat4 view;
    vec3 lightPos;
    vec3 viewPos;
    vec3 lightColor;
    vec4 frustumPlanes[6];
} sceneData;

layout(std140) uniform LargeObjectCullConstants {
    uint u_objectCount;
    uint u_maxDraws;
    float u_largeObjectThreshold;
};

layout(std430) buffer VisibleLargeObjectAtomicCounter {
    uint visibleLargeObjectCount;
};

layout(std430) buffer VisibleLargeObjectBuffer {
    uint visibleLargeObjects[];
};

layout(std430) readonly buffer ObjectBuffer {
    TransformComponent transforms[];
};

layout(std430) readonly buffer MeshInfoBuffer {
    MeshInfo meshInfos[];
};

layout(std430) readonly buffer RenderableBuffer {
    RenderableComponent renderables[];
};

const float FRUSTUM_PADDING_FACTOR = 1.05f;

bool isVisible(vec3 world_pos, float radius) {
    for (int i = 0; i < 6; i++) {
        if (dot(sceneData.frustumPlanes[i].xyz, world_pos) + sceneData.frustumPlanes[i].w < -radius) {
            return false;
        }
    }
    return true;
}

void main() {
    uint objectId = gl_GlobalInvocationID.x;
    if (objectId >= u_objectCount) return;

    RenderableComponent renderable = renderables[objectId];
    if (renderable.alpha < 1.0) return;

    mat4 modelMatrix = transforms[objectId].worldMatrix;
    MeshInfo mesh = meshInfos[renderable.mesh_uuid];

    vec4 world_pos_vec4 = modelMatrix * mesh.boundingCenter;
    vec3 world_pos = world_pos_vec4.xyz;

    float world_radius = mesh.boundingRadius * max(length(modelMatrix[0]), max(length(modelMatrix[1]), length(modelMatrix[2])));

    if (isVisible(world_pos, world_radius * FRUSTUM_PADDING_FACTOR)) {
        float dist = distance(world_pos, sceneData.viewPos);
        if (dist > 0.0) {
            float projectedSize = world_radius / dist;
            if (projectedSize < u_largeObjectThreshold) {
                return;
            }
        }

        uint index = atomicAdd(visibleLargeObjectCount, 1);

        if (index < u_maxDraws) {
            visibleLargeObjects[index] = objectId;
        }
    }
}